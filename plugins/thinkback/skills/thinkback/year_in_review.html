<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>2025 Year in Review - Download</title>
    <style>
        body {
            background: #191919;
            color: #FAFAF7;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            margin: 0;
            padding: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        h1 {
            margin-bottom: 20px;
            color: #E3703F;
        }
        #status {
            margin-bottom: 20px;
            color: #91918D;
        }
        #progress {
            margin-bottom: 20px;
            color: #FAFAF7;
        }
        button {
            background: #E3703F;
            color: #191919;
            border: none;
            padding: 12px 24px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background: #D4A27F;
        }
        button:disabled {
            background: #40403E;
            color: #666663;
            cursor: not-allowed;
        }
        #reminder {
            display: none;
            margin-top: 24px;
            padding: 16px 24px;
            background: #2a2a28;
            border: 1px solid #40403E;
            border-radius: 6px;
            max-width: 500px;
            text-align: center;
        }
        #reminder h3 {
            color: #E3703F;
            margin: 0 0 12px 0;
            font-size: 14px;
        }
        #reminder p {
            color: #91918D;
            margin: 0 0 8px 0;
            font-size: 13px;
            line-height: 1.5;
        }
        #reminder code {
            background: #191919;
            padding: 2px 6px;
            border-radius: 3px;
            color: #FAFAF7;
        }
    </style>
</head>
<body>
    <h1>Claude Code: 2025 Year in Review</h1>
    <div id="status">Ready to generate video</div>
    <div id="progress"></div>
    <button id="downloadBtn">Generate & Download Video</button>
    <div id="reminder">
        <h3>Before sharing your Thinkback</h3>
        <p>Please review the video for any sensitive or confidential information (project names, commits, etc.)</p>
        <p>To make changes, run <code>/thinkback</code> again and select "edit" or "regenerate".</p>
    </div>

    <!-- Hidden canvas for off-screen rendering -->
    <canvas id="canvas" width="1152" height="1040" style="display: none;"></canvas>

    <!-- MP4 muxer for WebCodecs output -->
    <script src="https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.3/build/mp4-muxer.min.js"></script>

    <!-- Load animation helpers (sets globalThis) -->
    <script src="helpers/transitions.js"></script>
    <script src="helpers/backgrounds.js"></script>
    <script src="helpers/text_effects.js"></script>
    <script src="helpers/particles.js"></script>
    <script src="helpers/borders.js"></script>
    <script src="helpers/scene_system.js"></script>
    <script src="helpers/awards_effects.js"></script>
    <script src="helpers/news_effects.js"></script>
    <script src="helpers/rpg_effects.js"></script>
    <script src="year_in_review.js"></script>

    <script>
    // Global error handler to display errors visibly
    window.onerror = function(msg, url, lineNo, columnNo, error) {
        const status = document.getElementById('status');
        const progress = document.getElementById('progress');
        if (status) {
            status.style.color = '#ff6b6b';
            status.textContent = 'Error: ' + msg;
        }
        if (progress) {
            progress.style.color = '#ff6b6b';
            progress.style.whiteSpace = 'pre-wrap';
            progress.style.textAlign = 'left';
            progress.style.maxWidth = '800px';
            const file = url ? url.split('/').pop() : 'unknown';
            progress.textContent = `File: ${file}\nLine: ${lineNo}, Col: ${columnNo}\n\n${error ? error.stack : ''}\n\nPlease run /thinkback again in Claude Code to regenerate the animation.`;
        }
        const btn = document.getElementById('downloadBtn');
        if (btn) btn.disabled = true;
        return false;
    };

    (function() {
        if (!globalThis.YearInReviewScenes) {
            throw new Error('YearInReviewScenes not loaded. Check year_in_review.js for syntax errors.');
        }
        const { mainAnimation, TOTAL_FRAMES } = globalThis.YearInReviewScenes;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const DPI_SCALE = 2;
        const CHAR_WIDTH = 7.2;
        const CHAR_HEIGHT = 13;
        const COLS = 80;
        const ROWS = 40;
        const FPS = 24;

        ctx.scale(DPI_SCALE, DPI_SCALE);

        class FrameBuffer {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.buffer = [];
                this.colorBuffer = [];
                this.clear();
            }

            clear() {
                this.buffer = [];
                this.colorBuffer = [];
                for (let y = 0; y < this.height; y++) {
                    this.buffer[y] = [];
                    this.colorBuffer[y] = [];
                    for (let x = 0; x < this.width; x++) {
                        this.buffer[y][x] = ' ';
                        this.colorBuffer[y][x] = null;
                    }
                }
            }

            getPixel(x, y) {
                x = Math.floor(x);
                y = Math.floor(y);
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    return this.buffer[y][x];
                }
                return ' ';
            }

            setPixel(x, y, char, depth = 0, color = null) {
                x = Math.floor(x);
                y = Math.floor(y);
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    this.buffer[y][x] = char;
                    this.colorBuffer[y][x] = color;
                }
            }

            drawText(x, y, text, depth = 0, color = null) {
                x = Math.floor(x);
                y = Math.floor(y);
                for (let i = 0; i < text.length; i++) {
                    if (x + i >= 0 && x + i < this.width && y >= 0 && y < this.height) {
                        this.buffer[y][x + i] = text[i];
                        this.colorBuffer[y][x + i] = color;
                    }
                }
            }

            drawCenteredText(y, text, color = null) {
                const x = Math.floor((this.width - text.length) / 2);
                this.drawText(x, y, text, 0, color);
            }

            drawLargeText(x, y, text) {
                for (let i = 0; i < text.length; i++) {
                    const char = text[i].toUpperCase();
                    const pattern = FIGLET_FONT[char] || FIGLET_FONT[' '];
                    for (let row = 0; row < 5; row++) {
                        for (let col = 0; col < 5; col++) {
                            if (pattern[row][col] === '@') {
                                this.setPixel(x + i * 6 + col, y + row, '@');
                            }
                        }
                    }
                }
            }

            drawLargeTextCentered(y, text) {
                const totalWidth = text.length * 6;
                const x = Math.floor((this.width - totalWidth) / 2);
                this.drawLargeText(x, y, text);
            }

            drawHorizontalLine(x, y, length, char = '-') {
                for (let i = 0; i < length; i++) {
                    this.setPixel(x + i, y, char);
                }
            }

            drawBox(x, y, width, height, char = '+', filled = false) {
                if (filled) {
                    for (let dy = 0; dy < height; dy++) {
                        for (let dx = 0; dx < width; dx++) {
                            this.setPixel(x + dx, y + dy, char);
                        }
                    }
                } else {
                    for (let dx = 0; dx < width; dx++) {
                        this.setPixel(x + dx, y, char);
                        this.setPixel(x + dx, y + height - 1, char);
                    }
                    for (let dy = 0; dy < height; dy++) {
                        this.setPixel(x, y + dy, char);
                        this.setPixel(x + width - 1, y + dy, char);
                    }
                }
            }

            render() {
                ctx.fillStyle = '#191919';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = '12px monospace';

                // Block character rendering as rectangles for pixel-perfect display
                const halfW = CHAR_WIDTH / 2;
                const halfH = CHAR_HEIGHT / 2;

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const char = this.buffer[y][x];
                        if (char !== ' ') {
                            const color = this.colorBuffer[y][x] || '#FAFAF7';
                            const px = x * CHAR_WIDTH;
                            const py = y * CHAR_HEIGHT;
                            ctx.fillStyle = color;

                            // Render block characters as geometric shapes
                            switch (char) {
                                case '█': // Full block
                                    ctx.fillRect(px, py, CHAR_WIDTH + 0.5, CHAR_HEIGHT);
                                    break;
                                case '▌': // Left half
                                    ctx.fillRect(px, py, halfW, CHAR_HEIGHT);
                                    break;
                                case '▐': // Right half
                                    ctx.fillRect(px + halfW, py, halfW + 0.5, CHAR_HEIGHT);
                                    break;
                                case '▀': // Top half
                                    ctx.fillRect(px, py, CHAR_WIDTH + 0.5, halfH);
                                    break;
                                case '▄': // Bottom half
                                    ctx.fillRect(px, py + halfH, CHAR_WIDTH + 0.5, halfH);
                                    break;
                                case '▛': // Top-left + top-right + bottom-left
                                    ctx.fillRect(px, py, CHAR_WIDTH + 0.5, halfH); // top
                                    ctx.fillRect(px, py + halfH, halfW, halfH); // bottom-left
                                    break;
                                case '▜': // Top-left + top-right + bottom-right
                                    ctx.fillRect(px, py, CHAR_WIDTH + 0.5, halfH); // top
                                    ctx.fillRect(px + halfW, py + halfH, halfW + 0.5, halfH); // bottom-right
                                    break;
                                case '▙': // Top-left + bottom-left + bottom-right
                                    ctx.fillRect(px, py + halfH, CHAR_WIDTH + 0.5, halfH); // bottom
                                    ctx.fillRect(px, py, halfW, halfH); // top-left
                                    break;
                                case '▟': // Top-right + bottom-left + bottom-right
                                    ctx.fillRect(px, py + halfH, CHAR_WIDTH + 0.5, halfH); // bottom
                                    ctx.fillRect(px + halfW, py, halfW + 0.5, halfH); // top-right
                                    break;
                                case '▘': // Top-left quadrant
                                    ctx.fillRect(px, py, halfW, halfH);
                                    break;
                                case '▝': // Top-right quadrant
                                    ctx.fillRect(px + halfW, py, halfW + 0.5, halfH);
                                    break;
                                case '▖': // Bottom-left quadrant
                                    ctx.fillRect(px, py + halfH, halfW, halfH);
                                    break;
                                case '▗': // Bottom-right quadrant
                                    ctx.fillRect(px + halfW, py + halfH, halfW + 0.5, halfH);
                                    break;
                                case '▓': // Dark shade
                                case '▒': // Medium shade
                                case '░': // Light shade
                                    ctx.fillRect(px, py, CHAR_WIDTH + 0.5, CHAR_HEIGHT);
                                    break;
                                default:
                                    // Regular text character
                                    ctx.fillText(char, px, (y + 1) * CHAR_HEIGHT);
                            }
                        }
                    }
                }
            }
        }

        const fb = new FrameBuffer(COLS, ROWS);

        function updateProgress(frame, phase = 'Rendering') {
            const percent = Math.round((frame / TOTAL_FRAMES) * 100);
            document.getElementById('progress').textContent = `${phase}: ${percent}% (${frame}/${TOTAL_FRAMES})`;
        }

        function renderFrame(frame) {
            fb.clear();
            mainAnimation(fb, frame);
            fb.render();
        }

        // Check if WebCodecs is available
        function hasWebCodecs() {
            return typeof VideoEncoder !== 'undefined' && typeof VideoFrame !== 'undefined';
        }

        // Fast generation using WebCodecs
        async function generateWithWebCodecs() {
            const status = document.getElementById('status');
            status.textContent = 'Generating video...';

            const muxer = new Mp4Muxer.Muxer({
                target: new Mp4Muxer.ArrayBufferTarget(),
                video: {
                    codec: 'avc',
                    width: canvas.width,
                    height: canvas.height
                },
                fastStart: 'in-memory'
            });

            let frameCount = 0;
            const frameDuration = 1_000_000 / FPS; // microseconds

            const encoder = new VideoEncoder({
                output: (chunk, meta) => {
                    muxer.addVideoChunk(chunk, meta);
                },
                error: (e) => console.error('Encoder error:', e)
            });

            encoder.configure({
                codec: 'avc1.640028',
                width: canvas.width,
                height: canvas.height,
                bitrate: 5_000_000,
                framerate: FPS
            });

            // Render and encode all frames as fast as possible
            for (let frame = 0; frame < TOTAL_FRAMES; frame++) {
                renderFrame(frame);
                updateProgress(frame, 'Encoding');

                const videoFrame = new VideoFrame(canvas, {
                    timestamp: frame * frameDuration,
                    duration: frameDuration
                });

                encoder.encode(videoFrame, { keyFrame: frame % 24 === 0 });
                videoFrame.close();
                frameCount++;

                // Yield to UI every 10 frames
                if (frame % 10 === 0) {
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            await encoder.flush();
            muxer.finalize();

            const buffer = muxer.target.buffer;
            const blob = new Blob([buffer], { type: 'video/mp4' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'year_in_review_2025.mp4';
            a.click();
            URL.revokeObjectURL(url);

            return 'mp4';
        }

        // Fallback: real-time MediaRecorder
        async function generateWithMediaRecorder() {
            const status = document.getElementById('status');
            status.textContent = 'Generating video...';

            const stream = canvas.captureStream(FPS);
            let options = {};
            let fileExtension = 'webm';

            if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1')) {
                options = { mimeType: 'video/mp4;codecs=avc1' };
                fileExtension = 'mp4';
            } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                options = { mimeType: 'video/webm;codecs=vp9' };
            } else if (MediaRecorder.isTypeSupported('video/webm')) {
                options = { mimeType: 'video/webm' };
            }

            const chunks = [];
            const recorder = new MediaRecorder(stream, options);

            recorder.ondataavailable = e => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            const downloadPromise = new Promise(resolve => {
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: options.mimeType || 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `year_in_review_2025.${fileExtension}`;
                    a.click();
                    URL.revokeObjectURL(url);
                    resolve();
                };
            });

            recorder.start();

            let frame = 0;
            await new Promise(resolve => {
                const interval = setInterval(() => {
                    renderFrame(frame);
                    updateProgress(frame, 'Recording');
                    frame++;
                    if (frame >= TOTAL_FRAMES) {
                        clearInterval(interval);
                        setTimeout(() => {
                            recorder.stop();
                            resolve();
                        }, 100);
                    }
                }, 1000 / FPS);
            });

            await downloadPromise;
            return fileExtension;
        }

        async function generateAndDownload() {
            const btn = document.getElementById('downloadBtn');
            const status = document.getElementById('status');

            btn.disabled = true;
            const startTime = performance.now();

            let fileExtension;
            try {
                if (hasWebCodecs()) {
                    fileExtension = await generateWithWebCodecs();
                } else {
                    fileExtension = await generateWithMediaRecorder();
                }
            } catch (e) {
                console.warn('WebCodecs failed, falling back to MediaRecorder:', e);
                fileExtension = await generateWithMediaRecorder();
            }

            const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
            status.textContent = `Video saved as year_in_review_2025.${fileExtension} (${elapsed}s)`;
            document.getElementById('progress').textContent = '';
            document.getElementById('reminder').style.display = 'block';
            btn.disabled = false;
        }

        document.getElementById('downloadBtn').addEventListener('click', generateAndDownload);
    })();
    </script>
</body>
</html>
